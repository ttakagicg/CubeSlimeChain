using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;

[Serializable]
public class ExplosionSettings
{
    //Minimum Position from the origin of initialized destructed parts when initiated
    public Vector3 initPositionMin = new Vector3(-0.5f, 0, -0.5f);

    //Maximum position offset from the origin of initiation
    public Vector3 initPositionMax = new Vector3(0.5f, 0.5f, 0.5f);

    //Radius of explosion
    public float explosionRadius = 5.0f;

    //Explosion Power Min
    public float explosionMin = 300.0f;

    //Explosion Power Max
    public float explosionMax = 500.0f;
}

[Serializable]
public class ExplodedSurfaces
{
    //When this is true the destructed surface can be removed
    public bool ShouldBeRemovedInTime = true;

    //How many second it should wait before destruction
    public float DestroyInSeconds = 1.0f;

    //when this value set to be true the surface generated by explosion spawned inside the desired layer
    public bool useLayerMask = false;

    //the desired layer name should be availble or be added in layer list
    public string LayerName = "";
}

[Serializable]
public class DestructibleProperties
{
    //Mesh to destruct
    public Transform MeshToExplode = null;

    //When this value is true it can be destroyd by damage casters
    public bool destructByDamage = false;

    //When this value is true the desired destructible item will be destructed at the scene start
    public bool autoDestruct = false;

    public float autoDestructDelay = 0.0f;

    //health of destructable item
    public float health = 100.0f;
}

[AddComponentMenu("Noir Project/Easy Destruction/Easy Destruction")]
public class EasyDestruction : MonoBehaviour {

    public DestructibleProperties destructibleProperties = null;
    public ExplosionSettings explosionSettings = null;
    public ExplodedSurfaces explodedSurfaces = null;

    //this function can handle the damage to the destructible item
    public void castDamage(float damage)
    {
        destructibleProperties.health -= damage;

        if (destructibleProperties.health <= 0)
        {
            explode(this.transform);
        }
    }

    public float getHealth()
    {
        return destructibleProperties.health;
    }

    public void explode(Transform transform)
    {
        MeshFilter meshFilter = null;
        SkinnedMeshRenderer skinned = null;
        Collider col = null;
        MeshRenderer meshRenderer = null;
        Renderer renderer = null;

        if (transform.GetComponent<MeshFilter>() != null)
            meshFilter = transform.GetComponent<MeshFilter>();

        if (transform.GetComponent<SkinnedMeshRenderer>() != null)
            skinned = transform.GetComponent<SkinnedMeshRenderer>();

        if (transform.GetComponent<Collider>() != null)
            col = transform.GetComponent<Collider>();

        if (transform.GetComponent<MeshRenderer>() != null)
            meshRenderer = transform.GetComponent<MeshRenderer>();

        if (transform.GetComponent<Renderer>() != null)
            renderer = transform.GetComponent<Renderer>();


        if (meshFilter == null && skinned == null)
        {
           return;
        }

        if (col)
        {
            col.enabled = false;
        }

        Mesh M = new Mesh();
        if (meshFilter)
        {
            M = meshFilter.mesh;
        }
        else if (skinned)
        {
            M = skinned.sharedMesh;
        }

        Material[] materials = new Material[0];
        if (meshRenderer)
        {
            materials = meshRenderer.materials;
        }
        else if (skinned)
        {
            materials = skinned.materials;
        }

        Vector3[] vertices = M.vertices;
        Vector3[] normals = M.normals;
        Vector2[] txCoords = M.uv;
        for (int submesh = 0; submesh < M.subMeshCount; submesh++)
        {

            int[] indices = M.GetTriangles(submesh);

            for (int i = 0; i < indices.Length; i += 3)
            {
                Vector3[] newVerts = new Vector3[3];
                Vector3[] newNormals = new Vector3[3];
                Vector2[] newUvs = new Vector2[3];
                for (int n = 0; n < 3; n++)
                {
                    int index = indices[i + n];
                    newVerts[n] = vertices[index];
                    newUvs[n] = txCoords[index];
                    newNormals[n] = normals[index];
                }

                Mesh mesh = new Mesh();
                mesh.vertices = newVerts;
                mesh.normals = newNormals;
                mesh.uv = newUvs;

                mesh.triangles = new int[] { 0, 1, 2, 2, 1, 0 };

                GameObject newSurface = new GameObject("destructedPart No. " + (i / 3));

                //when layer mask is checked user the layer name as the layer should mask the exploded parts
                //this will help to exploded parts not collide with the other mandatory game colliders and for this reason
                //you should make some changes in editor physics
                if (explodedSurfaces.useLayerMask)
                {
                    newSurface.layer = LayerMask.NameToLayer(explodedSurfaces.LayerName);
                }

                //newSurface.transform.position = transform.position;
                Vector3 wpos = transform.position;
                wpos.y += 0.5f;
                newSurface.transform.position = wpos;
                newSurface.transform.rotation = transform.rotation;
                newSurface.transform.localScale = transform.localScale/3;
                //Debug.Log("submesh: " + submesh);
                newSurface.AddComponent<MeshRenderer>().material = materials[submesh];
                newSurface.AddComponent<MeshFilter>().mesh = mesh;
                newSurface.AddComponent<BoxCollider>();

                Vector3 explosionPos = new Vector3(
                    transform.position.x + UnityEngine.Random.Range(explosionSettings.initPositionMin.x, explosionSettings.initPositionMax.x), 
                    transform.position.y + UnityEngine.Random.Range(explosionSettings.initPositionMin.y, explosionSettings.initPositionMax.y), 
                    transform.position.z + UnityEngine.Random.Range(explosionSettings.initPositionMin.z, explosionSettings.initPositionMax.z));

                newSurface.AddComponent<Rigidbody>().AddExplosionForce(UnityEngine.Random.Range(explosionSettings.explosionMin, explosionSettings.explosionMax), explosionPos, explosionSettings.explosionRadius);

                if (explodedSurfaces.ShouldBeRemovedInTime == true)
                    Destroy(newSurface, explodedSurfaces.DestroyInSeconds + UnityEngine.Random.Range(0.0f, explodedSurfaces.DestroyInSeconds));
            }
        }

        renderer.enabled = false;
    }

    //Initialization function
    public void Start()
    {
        //is auto destruct mode enabled?
        if (destructibleProperties.autoDestruct)
        {
            //Call auto destruction with timer
            StartCoroutine(autoDestruct());
        }
    }

    public IEnumerator autoDestruct()
    {
        yield return new WaitForSeconds(destructibleProperties.autoDestructDelay);

        //When mesh to explode isnt set, use the assigned component mesh as mesh to explode.
        if (destructibleProperties.MeshToExplode == null)
        {
            //set the explodee as this transform
            destructibleProperties.MeshToExplode = this.transform;
        }
        
        yield return null;
        
        //Make the mesh explode
        explode(destructibleProperties.MeshToExplode);
        yield return null;
    }

    public void Update()
    {
        //when destructible set to be destruct by the damage
        if (destructibleProperties.destructByDamage)
        {

        }
    }
}
